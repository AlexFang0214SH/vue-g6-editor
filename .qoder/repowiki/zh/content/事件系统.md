# 事件系统

<cite>
**Referenced Files in This Document**  
- [index.vue](file://src/views/index.vue)
- [mixin.js](file://src/views/mixin.js)
- [g6-editor.md](file://doc/v1/g6-editor.md)
- [README.md](file://README.md)
</cite>

## 目录
1. [事件监听与响应机制概述](#事件监听与响应机制概述)
2. [常用事件类型与触发时机](#常用事件类型与触发时机)
3. [事件处理器注册示例](#事件处理器注册示例)
4. [事件系统在状态一致性中的作用](#事件系统在状态一致性中的作用)
5. [事件冒泡与默认行为处理](#事件冒泡与默认行为处理)
6. [性能优化技巧](#性能优化技巧)
7. [调试建议](#调试建议)

## 事件监听与响应机制概述

vue-g6-editor基于G6 Editor构建，其事件系统通过原生事件机制实现Vue组件与画布状态的同步。在Vue组件中，通过`currentPage.on()`方法注册事件监听器，捕获G6 Editor触发的各类事件，进而更新Vue数据模型，确保视图与状态的一致性。

该机制的核心在于将G6 Editor的底层事件（如`afteradditem`、`afterremoveitem`、`afterchangegroup`）与Vue的响应式系统连接。当画布上的元素发生变更时，G6 Editor会触发相应的事件，Vue组件通过预设的事件处理器捕获这些事件，并执行`this.$set`或直接修改`data`中的响应式属性，从而驱动视图更新。

**Section sources**
- [index.vue](file://src/views/index.vue#L366-L402)
- [g6-editor.md](file://doc/v1/g6-editor.md#L644-L659)

## 常用事件类型与触发时机

根据文档和代码分析，以下是vue-g6-editor中常用的核心事件及其触发时机：

| 事件名称 | 触发时机 | 提供者 |
| :--- | :--- | :--- |
| `afterchange` | 任何画布元素发生变更后（如添加、删除、更新） | page 画布 |
| `afteritemselected` | 元素被选中后 | page 画布 |
| `afteritemunselected` | 已选中元素被取消选中后 | page 画布 |
| `afterdelete` | 元素被删除后 | page 画布 |
| `aftercommandexecute` | 命令执行后 | editor 编辑器 |
| `beforecommandexecute` | 命令执行前 | editor 编辑器 |
| `statuschange` | 画布状态发生改变时 | page 画布 |
| `click` | 画布被点击时 | page 画布 |
| `contextmenu` | 画布上触发右键菜单时 | page 画布 |

**Section sources**
- [g6-editor.md](file://doc/v1/g6-editor.md#L660-L696)

## 事件处理器注册示例

在Vue组件中，通过`currentPage.on()`方法注册事件处理器。以下是在`mounted`生命周期钩子中注册事件监听器的典型代码模式：

```javascript
// 获取当前画布
const currentPage = editor.getCurrentPage();

// 监听“任何改变发生后”事件
currentPage.on("afterchange", (e) => {
  if (e.action === "add") {
    if (e.model.nodetype === "startNode" || e.model.nodetype === "endNode") {
      let nodes = this.editor.getCurrentPage().getNodes();
      for (const item of nodes) {
        if (item.model.nodetype === e.model.nodetype && item.model.id !== e.model.id) {
          this.editor.getCurrentPage().remove(e.item);
          this.$message.warning("只能有一个开始节点或结束节点");
        }
      }
    }
  }
});

// 监听“选择对象后”事件
currentPage.on("afteritemselected", (ev) => {
  console.log("打印所选对象属性", ev.item);
  console.log("打印所选对象数据模型", ev.item.model);
  const selectedItemDataModel = ev.item.model;
  // 如果选择的对象是节点
  if (ev.item.isNode) {
    this.nodeAttributeForm.label = selectedItemDataModel.label;
    this.nodeAttributeForm.width = selectedItemDataModel.size.split("*")[0];
    this.nodeAttributeForm.height = selectedItemDataModel.size.split("*")[1];
    this.nodeAttributeForm.color = selectedItemDataModel.color;
  }
  // 如果选择的对象是边
  if (ev.item.isEdge) {
    ev.item.graph.edge({
      shape: "flow-polyline-round"
    });
    this.edgeAttributeForm.label = selectedItemDataModel.label;
    this.edgeAttributeForm.shape = selectedItemDataModel.shape;
  }
});
```

此示例展示了如何监听`afterchange`和`afteritemselected`事件，并根据事件对象`e`或`ev`中的数据来更新Vue组件的`data`属性（如`nodeAttributeForm`），从而实现属性面板的动态更新。

**Section sources**
- [index.vue](file://src/views/index.vue#L366-L402)

## 事件系统在状态一致性中的作用

事件系统是维持Vue数据模型与G6画布状态一致性的核心桥梁。其作用机制如下：

1.  **单向数据流**：用户在画布上的所有操作（如拖拽节点、连接边）都会被G6 Editor捕获并触发相应的事件。
2.  **事件捕获**：Vue组件通过`on()`方法监听这些事件，作为数据流的入口。
3.  **状态同步**：事件处理器根据事件对象中携带的数据（如`ev.item.model`）来更新Vue组件的`data`属性。例如，当一个节点被选中时，`afteritemselected`事件会携带该节点的完整数据模型，处理器将其同步到`nodeAttributeForm`中。
4.  **视图驱动**：由于`data`属性是响应式的，对`nodeAttributeForm`等属性的修改会立即触发属性面板等Vue组件的重新渲染，从而在UI上反映出画布的当前状态。

这种机制确保了“画布状态 -> Vue数据 -> UI视图”的同步，避免了状态不一致的问题。

**Section sources**
- [index.vue](file://src/views/index.vue#L366-L402)
- [mixin.js](file://src/views/mixin.js#L5-L20)

## 事件冒泡与默认行为处理

在vue-g6-editor的当前实现中，未显式处理事件冒泡或阻止默认行为。G6 Editor的事件系统主要在画布（`page`）层面进行管理，事件的传播和处理由其内部机制控制。

对于Vue组件内部的DOM事件（如工具栏按钮的`@click`），Vue的事件系统会处理其冒泡。例如，工具栏中的`<i @click="readHistoryData">`会正常触发Vue的`readHistoryData`方法，其默认行为（如链接跳转）通常不存在或已被忽略。

若需阻止G6 Editor的某个事件的默认行为，理论上可以在`before`事件（如`beforechange`）中通过返回`false`来实现，但当前代码库中未使用此模式。

**Section sources**
- [index.vue](file://src/views/index.vue#L0-L23)
- [g6-editor.md](file://doc/v1/g6-editor.md#L660-L696)

## 性能优化技巧

对于复杂的交互场景（如拖拽过程中实时预览），直接在事件处理器中执行耗时操作可能导致性能瓶颈。虽然当前代码库中未实现节流（throttling）或防抖（debouncing），但以下技巧可用于优化：

1.  **事件节流**：对于高频触发的事件（如`mousemove`），可以使用`lodash.throttle`或原生`setTimeout`来限制处理器的执行频率，避免过度更新。
2.  **批量更新**：利用`editor.executeCommand()`方法将多个画布操作包裹在一个命令中，这样只会触发一次`afterchange`事件，而不是每次操作都触发，从而减少Vue的更新次数。
3.  **选择性监听**：仅监听真正需要的事件，避免不必要的事件处理器占用资源。
4.  **避免在事件中进行复杂计算**：将复杂的逻辑（如数据转换）移出事件处理器，或使用`requestAnimationFrame`来优化。

**Section sources**
- [index.vue](file://src/views/index.vue#L366-L402)

## 调试建议

为了有效排查交互异常问题，可以采用以下调试方法：

1.  **使用浏览器控制台监听事件流**：
    ```javascript
    // 在控制台中查看当前画布的所有已注册事件
    let events = window.editor.getCurrentPage()._events;
    console.log(events);
    ```
    这有助于确认事件监听器是否已成功注册。

2.  **打印事件对象结构**：
    在事件处理器中使用`console.log()`打印事件对象，以检查其携带的数据是否符合预期。
    ```javascript
    currentPage.on("afteritemselected", (ev) => {
      console.log("事件对象:", ev);
      console.log("所选元素:", ev.item);
      console.log("数据模型:", ev.item.model);
    });
    ```

3.  **利用`window`对象进行调试**：
    代码中已将`editor`和`flow`实例挂载到`window`对象上（`window.editor = editor;`），可以在浏览器控制台中直接调用`editor.getCurrentPage().save()`等方法来检查画布的当前状态。

4.  **检查Vue组件状态**：
    使用Vue Devtools检查`data`属性（如`nodeAttributeForm`）是否随事件正确更新。

**Section sources**
- [index.vue](file://src/views/index.vue#L366-L402)
- [g6-editor.md](file://doc/v1/g6-editor.md#L697-L756)